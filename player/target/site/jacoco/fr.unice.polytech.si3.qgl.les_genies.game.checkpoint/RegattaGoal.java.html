<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RegattaGoal.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">les_genies</a> &gt; <a href="index.source.html" class="el_package">fr.unice.polytech.si3.qgl.les_genies.game.checkpoint</a> &gt; <span class="el_source">RegattaGoal.java</span></div><h1>RegattaGoal.java</h1><pre class="source lang-java linenums">package fr.unice.polytech.si3.qgl.les_genies.game.checkpoint;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import fr.unice.polytech.si3.qgl.les_genies.game.map.BoxMap;
import fr.unice.polytech.si3.qgl.les_genies.game.map.MapGrid;
import fr.unice.polytech.si3.qgl.les_genies.game.pathfinding.*;
import fr.unice.polytech.si3.qgl.les_genies.game.shapes.Circle;
import fr.unice.polytech.si3.qgl.les_genies.game.tools.Position;

import java.util.*;


public class RegattaGoal {
    private final String mode;
    private final Checkpoint[] checkpoints;
    @JsonIgnore
    private Checkpoint currentCheckpoint;
    @JsonIgnore
    private int indexCurrentCheckpoint;
<span class="fc" id="L22">    @JsonIgnore</span>
    private Checkpoint plCheckpoint = null;
    @JsonIgnore
    private final LinkedList&lt;Checkpoint&gt; pathCheckpointsQueue;
    @JsonIgnore
    private static final int CHECKPOINT_BOX_SIZE = 150;
    @JsonIgnore
    private final List&lt;Checkpoint&gt; checkpointsForDisplay;

    @JsonCreator
    public RegattaGoal(@JsonProperty(&quot;mode&quot;) String mode,
<span class="fc" id="L33">                       @JsonProperty(&quot;checkpoints&quot;) Checkpoint[] checkpoints) {</span>
<span class="fc" id="L34">        this.mode = mode;</span>
<span class="fc" id="L35">        this.checkpoints = checkpoints;</span>
<span class="fc" id="L36">        this.indexCurrentCheckpoint = 0;</span>
<span class="fc" id="L37">        this.pathCheckpointsQueue = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L38">        this.checkpointsForDisplay = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L39" title="1 of 2 branches missed.">        if (checkpoints.length &gt; 0) {</span>
<span class="fc" id="L40">            currentCheckpoint = checkpoints[0];</span>
        }
<span class="fc" id="L42">    }</span>

    public Checkpoint[] getCheckpoints() {
<span class="fc" id="L45">        return checkpoints;</span>
    }

    private boolean isLastCheckpoint() {
<span class="nc bnc" id="L49" title="All 2 branches missed.">        return checkpoints.length &lt;= indexCurrentCheckpoint + 1;</span>
    }

    public int getIndexCurrentCheckpoint() {
<span class="nc" id="L53">        return indexCurrentCheckpoint;</span>
    }

    /**
     * Return the current checkpoint
     *
     * @return Checkpoint
     */
    public Checkpoint getCurrentCheckpoint() {
<span class="fc" id="L62">        return currentCheckpoint;</span>
    }

    /**
     * Change the value of currentCheckpoint.
     * If return true : currentCheckpoint has successfully taken the value of the next checkpoint in the list
     * If return false : there is no more available checkpoint in the list. The value of currentCheckpoint will not change.
     *
     * @return boolean
     */
    public boolean getNextCheckpoint() {
<span class="nc bnc" id="L73" title="All 2 branches missed.">        if (!isLastCheckpoint()) {</span>
<span class="nc" id="L74">            indexCurrentCheckpoint++;</span>
<span class="nc" id="L75">            currentCheckpoint = checkpoints[indexCurrentCheckpoint];</span>

<span class="nc" id="L77">            return true;</span>
        }
<span class="nc" id="L79">        return false;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L84">        return &quot;RegattaGoal{&quot; +</span>
                &quot;mode='&quot; + mode + '\'' +
<span class="nc" id="L86">                &quot;, checkpoints=&quot; + Arrays.toString(checkpoints) +</span>
                &quot;, currentCheckpoint=&quot; + currentCheckpoint +
                &quot;, indexCurrentCheckpoint=&quot; + indexCurrentCheckpoint +
                '}';
    }

    public Checkpoint getCheckpoint(Position shipPosition, MapGrid map){
<span class="nc bnc" id="L93" title="All 4 branches missed.">        if(pathCheckpointsQueue.isEmpty() || currentCheckpoint.getShape().isOnShape(currentCheckpoint.getPosition(),shipPosition)) {</span>
<span class="nc" id="L94">            generatePathList(map, shipPosition);</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">        } else if (pathCheckpointsQueue.peek().getShape().isOnShape(pathCheckpointsQueue.peek().getPosition(), shipPosition)) {</span>
<span class="nc" id="L96">            checkpointsForDisplay.add(pathCheckpointsQueue.poll());</span>
<span class="nc" id="L97">            return getCheckpoint(shipPosition, map);</span>
        }
<span class="nc" id="L99">        return pathCheckpointsQueue.peek();</span>
    }

    public void generatePathList(MapGrid map, Position shipPosition){
<span class="fc" id="L103">        plCheckpoint = getCurrentCheckpoint();</span>
<span class="fc" id="L104">        PathA pathA = new PathA(map, shipPosition, plCheckpoint.getPosition());</span>
<span class="fc" id="L105">        List&lt;NodeA&gt; path = pathA.findPath();</span>
<span class="fc" id="L106">        pathCheckpointsQueue.clear();</span>

<span class="fc bfc" id="L108" title="All 2 branches covered.">        for (NodeA node : path) {</span>
<span class="fc" id="L109">            pathCheckpointsQueue.add(createCheckpoint(map.getBox(node)));</span>
<span class="fc" id="L110">        }</span>
<span class="fc" id="L111">        pathCheckpointsQueue.add(plCheckpoint);</span>
<span class="fc" id="L112">    }</span>

    Checkpoint createCheckpoint(BoxMap boxMap){
<span class="fc" id="L115">        return new Checkpoint(boxMap.getCenter(), new Circle(CHECKPOINT_BOX_SIZE*1.5));</span>
    }

    public List&lt;Checkpoint&gt; getListOpti() {
<span class="nc" id="L119">        return checkpointsForDisplay;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>